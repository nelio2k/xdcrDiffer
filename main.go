// Copyright (c) 2018 Couchbase, Inc.
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied. See the License for the specific language governing permissions
// and limitations under the License.

package main

import (
	"flag"
	"fmt"
	"os"
	"xdcrDiffer/observer"
	"xdcrDiffer/utils"

	"github.com/spf13/pflag"
	"github.com/spf13/viper"

	"xdcrDiffer/base"
	"xdcrDiffer/difftool"
)

var done = make(chan bool)

var options base.Options

// Deprecated - do not add more keys, but instead, use viper
func argParse() error {
	flag.StringVar(&options.SourceUrl, base.SourceUrlKey, "",
		"url for source cluster")
	flag.StringVar(&options.SourceUsername, base.SourceUsernameKey, "",
		"username for source cluster")
	flag.StringVar(&options.SourcePassword, base.SourcePasswordKey, "",
		"password for source cluster")
	flag.StringVar(&options.SourceBucketName, base.SourceBucketNameKey, "",
		"bucket name for source cluster")
	flag.StringVar(&options.RemoteClusterName, base.RemoteClusterNameKey, "",
		"Remote cluster reference name used when creating it")
	flag.StringVar(&options.SourceFileDir, base.SourceFileDirKey, base.SourceFileDir,
		"directory to store mutations in source cluster")
	flag.StringVar(&options.TargetUrl, base.TargetUrlKey, "",
		"url for target cluster")
	flag.StringVar(&options.TargetUsername, base.TargetUsernameKey, "",
		"username for target cluster")
	flag.StringVar(&options.TargetPassword, base.TargetPasswordKey, "",
		"password for target cluster")
	flag.StringVar(&options.TargetBucketName, base.TargetBucketNameKey, "",
		"bucket name for target cluster")
	flag.StringVar(&options.TargetFileDir, base.TargetFileDirKey, base.TargetFileDir,
		"directory to store mutations in target cluster")
	flag.Uint64Var(&options.NumberOfSourceDcpClients, base.NumberOfSourceDcpClientsKey, 1,
		"number of source dcp clients")
	flag.Uint64Var(&options.NumberOfWorkersPerSourceDcpClient, base.NumberOfWorkersPerSourceDcpClientKey, 64,
		"number of workers for each source dcp client")
	flag.Uint64Var(&options.NumberOfTargetDcpClients, base.NumberOfTargetDcpClientsKey, 1,
		"number of target dcp clients")
	flag.Uint64Var(&options.NumberOfWorkersPerTargetDcpClient, base.NumberOfWorkersPerTargetDcpClientKey, 64,
		"number of workers for each target dcp client")
	flag.Uint64Var(&options.NumberOfWorkersForFileDiffer, "NumberOfWorkersForFileDiffer", 30,
		"number of worker threads for file differ ")
	flag.Uint64Var(&options.NumberOfWorkersForMutationDiffer, base.NumberOfWorkersForMutationDifferKey, 30,
		"number of worker threads for mutation differ ")
	flag.Uint64Var(&options.NumberOfBins, base.NumberOfBinsKey, 5,
		"number of buckets per vbucket")
	flag.Uint64Var(&options.NumberOfFileDesc, base.NumberOfFileDescKey, 500,
		"number of file descriptors")
	flag.Uint64Var(&options.CompleteByDuration, base.CompleteByDurationKey, 0,
		"duration that the tool should run")
	flag.BoolVar(&options.CompleteBySeqno, base.CompleteBySeqnoKey, true,
		"whether tool should automatically complete (after processing all mutations at start time)")
	flag.StringVar(&options.CheckpointFileDir, base.CheckpointFileDirKey, base.CheckpointFileDir,
		"directory for checkpoint files")
	flag.StringVar(&options.OldSourceCheckpointFileName, base.OldSourceCheckpointFileNameKey, "",
		"old source checkpoint file to load from when tool starts")
	flag.StringVar(&options.OldTargetCheckpointFileName, "OldTargetCheckpointFileName", "",
		"old target checkpoint file to load from when tool starts")
	flag.StringVar(&options.NewCheckpointFileName, base.NewCheckpointFileNameKey, "",
		"new checkpoint file to write to when tool shuts down")
	flag.StringVar(&options.FileDifferDir, base.FileDifferDirKey, base.FileDifferDir,
		" directory for storing diffs generated by file differ")
	flag.StringVar(&options.MutationDifferDir, base.MutationDifferDirKey, base.MutationDifferDir,
		" output directory for mutation differ")
	flag.Uint64Var(&options.MutationDifferBatchSize, base.MutationDifferBatchSizeKey, 100,
		"size of batch used by mutation differ")
	flag.Uint64Var(&options.MutationDifferTimeout, base.MutationDifferTimeoutKey, 30,
		"timeout, in seconds, used by mutation differ")
	flag.Uint64Var(&options.SourceDcpHandlerChanSize, base.SourceDcpHandlerChanSizeKey, base.DcpHandlerChanSize,
		"size of source dcp handler channel")
	flag.Uint64Var(&options.TargetDcpHandlerChanSize, base.TargetDcpHandlerChanSizeKey, base.DcpHandlerChanSize,
		"size of target dcp handler channel")
	flag.Uint64Var(&options.BucketOpTimeout, base.BucketOpTimeoutKey, base.BucketOpTimeout,
		" timeout for bucket for stats collection, in seconds")
	flag.Uint64Var(&options.MaxNumOfGetStatsRetry, base.MaxNumOfGetStatsRetryKey, base.MaxNumOfGetStatsRetry,
		"max number of retry for get stats")
	flag.Uint64Var(&options.MaxNumOfSendBatchRetry, base.MaxNumOfSendBatchRetryKey, base.MaxNumOfSendBatchRetry,
		"max number of retry for send batch")
	flag.Uint64Var(&options.GetStatsRetryInterval, base.GetStatsRetryIntervalKey, base.GetStatsRetryInterval,
		" retry interval for get stats, in seconds")
	flag.Uint64Var(&options.SendBatchRetryInterval, base.SendBatchRetryIntervalKey, base.SendBatchRetryInterval,
		"retry interval for send batch, in milliseconds")
	flag.Uint64Var(&options.GetStatsMaxBackoff, base.GetStatsMaxBackoffKey, base.GetStatsMaxBackoff,
		"max backoff for get stats, in seconds")
	flag.Uint64Var(&options.SendBatchMaxBackoff, base.SendBatchMaxBackoffKey, base.SendBatchMaxBackoff,
		"max backoff for send batch, in seconds")
	flag.Uint64Var(&options.DelayBetweenSourceAndTarget, base.DelayBetweenSourceAndTargetKey, base.DelayBetweenSourceAndTarget,
		"delay between source cluster start up and target cluster start up, in seconds")
	flag.Uint64Var(&options.CheckpointInterval, base.CheckpointIntervalKey, base.CheckpointInterval,
		"interval for periodical checkpointing, in seconds")
	flag.BoolVar(&options.RunDataGeneration, base.RunDataGenerationKey, true,
		" whether to run data generation")
	flag.BoolVar(&options.RunFileDiffer, base.RunFileDifferKey, true,
		" whether to file differ")
	flag.BoolVar(&options.RunMutationDiffer, base.RunMutationDifferKey, true,
		" whether to verify diff keys through aysnc Get on clusters")
	flag.BoolVar(&options.EnforceTLS, base.EnforceTLSKey, false,
		" stops executing if pre-requisites are not in place to ensure TLS communications")
	flag.IntVar(&options.BucketBufferCapacity, base.BucketBufferCapacityKey, base.BucketBufferCapacity,
		"  number of items kept in memory per binary buffer bucket")
	flag.BoolVar(&options.CompareBody, base.CompareBodyKey, false,
		" whether to use Get instead of GetMeta during mutationDiff")
	flag.IntVar(&options.MutationDifferRetries, base.MutationRetriesKey, 0,
		"Additional number of times to retry to resolve the mutation differences")
	flag.IntVar(&options.MutationDifferRetriesWaitSecs, base.MutationRetriesWaitSecsKey, 60,
		"Seconds to wait in between retries for mutation differences")
	// Deprecated: The number of arguments that are being passed in is increasing
	// Thus, we're moving towards using viper to parse a configuration JSON
	// Note that the way viper works is that it'll parse the flags that already exist, but
	// if a key-value pair is specified in the later config file, the config specification will
	// be overwritten by the specified flag in the command line argument
	// This is to ensure backwards-compatibility with potential existing customer scripts
	viper.SetConfigFile(base.ViperConfigFile)
	viper.AddConfigPath(".")
	err := viper.ReadInConfig()
	if err != nil {
		return fmt.Errorf("Unable to read in viper config file: %v", err)
	}

	flag.Parse()
	pflag.CommandLine.AddGoFlagSet(flag.CommandLine)
	return viper.BindPFlags(pflag.CommandLine)
}

func maybeSetEnv(key, value string) {
	if os.Getenv(key) != "" {
		return
	}
	os.Setenv(key, value)
}

func main() {
	if err := argParse(); err != nil {
		fmt.Printf("%v\n", err)
		os.Exit(1)
	}

	if options.EnforceTLS {
		// For using certificates, the source cluster must be on a loopback device since we will be retrieving the
		// source cluster's certificate to prevent sniffing
		if !utils.IsURLLoopBack(options.SourceUrl) {
			fmt.Printf("EnforceTLS options requires that source addr %v to use loopback device\n",
				options.SourceUrl)
			os.Exit(1)
		}
	}

	// Launch appropriate modes
	switch viper.GetBool(base.ObserveModeKey) {
	case true:
		runObserver()
	case false:
		runDiffer()
	}
}

func runDiffer() {
	fmt.Printf("differ is run with options: %+v\n", options)
	legacyMode := len(options.TargetUsername) > 0

	difftool, err := difftool.NewDiffTool(legacyMode, &options)
	if err != nil {
		fmt.Printf("Error creating difftool: %v\n", err)
		os.Exit(1)
	}

	// Capture any Ctrl-C for continuing to next steps or cleanup
	go difftool.MonitorInterruptSignal()

	if legacyMode {
		if options.EnforceTLS {
			fmt.Printf("EnforceTLS option is not compatible with legacyMode")
			os.Exit(1)
		}
		// OK to ignore metakv err in manual mode
		if err := difftool.PopulateTemporarySpecAndRef(); err != nil {
			fmt.Printf("%v\n", err)
			os.Exit(1)
		}
	}

	if err := difftool.SetupDirectories(); err != nil {
		difftool.Logger().Errorf("Unable to set up directory structure: %v\n", err)
		os.Exit(1)
	}

	if err := difftool.RetrieveClustersCapabilities(legacyMode); err != nil {
		fmt.Printf("%v\n", err)
		os.Exit(1)
	}

	if options.RunDataGeneration {
		err := difftool.GenerateDataFiles()
		if err != nil {
			fmt.Printf("Error generating data files. err=%v\n", err)
			os.Exit(1)
		}
	} else {
		fmt.Printf("Skipping  generating data files since it has been disabled\n")
	}

	if options.RunFileDiffer {
		err := difftool.DiffDataFiles()
		if err != nil {
			fmt.Printf("Error running file difftool. err=%v\n", err)
			os.Exit(1)
		}
	} else {
		fmt.Printf("Skipping file difftool since it has been disabled\n")
	}

	if options.RunMutationDiffer {
		difftool.RunMutationDiffer()
	} else {
		fmt.Printf("Skipping mutation diff since it has been disabled\n")
	}
}

func runObserver() {
	getScopesCollectionMap := func() map[string]interface{} {
		return viper.GetStringMap(base.ObserveKeysKey)
	}
	observer, err := observer.NewObserverTool(getScopesCollectionMap)
	if err != nil {
		fmt.Errorf("Error creating observer: %v", err)
		os.Exit(1)
	}

	err = observer.Run()
	if err != nil {
		fmt.Errorf("Error running observer: %v", err)
		os.Exit(1)
	}
}
